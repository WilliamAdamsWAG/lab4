/**
 * goldbach.c
 *
 * Copyright (c) 2025, Nikita Chesnokov <chesnoko@cs.petrsu.ru>
 *
 * This code is licensed under MIT license.
 */
#include <stdio.h>
#include <stdlib.h>

#include "calculate_primes.h" // Подключаем заголовочный файл и получаем доступ к функции из calculate_primes.c

int count_pairs(int n, int primes[]);
int min_x(int n, int primes[]);

int main() {
    int n, m; // нижняя и верхняя граница диапазона

    scanf("%d %d", &n, &m);

    // int *primes                    - создаём переменную-указатель
    // malloc((m + 1) * sizeof(int))  - выделяем оперативную память под массив из m+1 элементов
    // (int*)                         - приводит результат функции malloc() к типу int
    int *primes = (int*)malloc((m + 1) * sizeof(int));

    calculate_primes(primes, m); // передаём указатель на массив и верхнюю границы, чтобы записать в primes таблицу простых чисел

    // Если диапазон начинается с нечётного числа добавляем 1
    // т.к. нам всё равно нужно будет начинать с числа на 1 больше
    if(n % 2 != 0) {
        n += 1;
    }

    // По аналогии, только тут уже убавляем 1, т.к. до мы всё равно не дойдём до этого числа
    if(m % 2 != 0) {
        m -= 1;
    }

    // Перебираем все числа в диапазоне [n, m]
    for(int i = n; i <= m; i+=2) {
        int c = count_pairs(i, primes); // Количество пар чисел, чья сумма ровняется исходному числу
        int x = min_x(i, primes);       // Ищем первый простой множитель для числа
        int y = i - x;                  // Т.к. Х у нас уже найден, чтобы найти Y достаточно отнять из числа значение X

        printf("%d %d %d %d \n", i, c, x, y);
    }

    free(primes);

    return EXIT_SUCCESS;
}

int count_pairs(int n, int primes[]) {
    int count = 0; // Количество пар чисел в сумме дающих N

    // Перебираем числа от 2 до половины N(т.к. отсеиваем дубликаты по типу 3+5 и 5+3)
    for(int i = 2; i <= n / 2; i++) {
        // Проверяем является ли I простым числом, а также N-I
        // (от самого числа отнимаем I что бы результат это вычитания в сумме с I давал N)
        if(primes[i] == 1 && primes[n-i] == 1) {
            count += 1;
        }
    }

    return count;
}

int min_x(int n, int primes[]) {
    // Перебираем числа от 2 до половины N(т.к. отсеиваем дубликаты по типу 3+5 и 5+3)
    for(int i = 2; i <= n / 2; i++) {
        // Проверяем является ли I простым числом, а также N-I
        // (от самого числа отнимаем I что бы результат это вычитания в сумме с I давал N)
        if(primes[i] == 1 && primes[n-i] == 1) {
            // Т.к. мы идём от маленького к большому то первое число попадающее под условие и является наименьшим X
            return i;
        }
    }

    return -1;
}